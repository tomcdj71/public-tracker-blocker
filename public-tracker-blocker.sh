#!/bin/bash
set -E -u
trap 'error_handler $LINENO $?' ERR

readonly CUSTOM_LIST="./custom-list.txt"
readonly BASE_LIST="./trackers-list.txt"
readonly ROOT_UID=0
if [ ! -f "$BASE_LIST" ]; then
    printf "Base list not found.\n"
    exit 1
fi
readonly CRON_HOUR=5
readonly CRON_FILE="/etc/cron.d/public-tracker-blocker"
readonly SCRIPT_PATH="/usr/local/bin/public-tracker-blocker"
declare RELOAD_NETWORK=false
declare WORKFLOW_MODE=false
declare -a URL_LIST
declare TEMP_HOSTS_FILE

function error_handler() {
    local ERROR_LINE=$1
    local ERROR_MESSAGE=$2
    printf "An error occurred on line %s: %s\n" "$ERROR_LINE" "$ERROR_MESSAGE"
    exit 1
}

function workflow_mode(){
    if $WORKFLOW_MODE; then
        readonly HOSTS_FILE="./hosts.example"
        readonly PLACEHOLDER="# Auto-generated by public-tracker-blocker"
    else
        readonly HOSTS_FILE="/etc/hosts"
        readonly PLACEHOLDER="# DO NOT DELETE THIS LINE"
    fi
}

function check_root() {
    if [ "$(id -u)" -ne "$ROOT_UID" ]; then
        printf "This script must be run as root.\n"
        exit 1
    fi
}

for cmd in "curl" "awk"; do
    command -v $cmd > /dev/null 2>&1 || { printf "%s is required but not installed.\n use apt-get install %s to install the dependency" "$cmd" "$cmd"; exit 1; }
done

function transform_url() {
    local URL="$1"
    local TRANSFORMED_URL="$URL"
    case "$URL" in
        https://github.com/*)
            local USER_REPO="${URL#https://github.com/}"
            USER_REPO="${USER_REPO%/blob/*}"
            local PATH="${URL##*/blob/}"
            TRANSFORMED_URL="https://raw.githubusercontent.com/$USER_REPO/$PATH"
        ;;
        https://pastebin.com/*)
            local ID="${URL##https://pastebin.com/}"
            TRANSFORMED_URL="https://pastebin.com/raw/$ID"
        ;;
    esac
    
    echo "$TRANSFORMED_URL"
}

function ensure_placeholder() {
    [ ! -f "$HOSTS_FILE" ] && touch "$HOSTS_FILE"
    grep -Fxq "$PLACEHOLDER" "$HOSTS_FILE" || echo "$PLACEHOLDER" >> "$HOSTS_FILE"
}

function fetch_base_list() {
    if [ -f "$CUSTOM_LIST" ]; then
        mapfile -t URL_LIST < <(cat "$BASE_LIST" "$CUSTOM_LIST" | while read -r line; do transform_url "$line"; done)
    else
        mapfile -t URL_LIST < <(while read -r line; do transform_url "$line"; done < "$BASE_LIST")
    fi
}

function truncate_hosts() {
    TEMP_HOSTS_FILE=$(mktemp)
    TEMP_HOSTS_FILE_SORTED=$(mktemp)
    awk -v placeholder="$PLACEHOLDER" 'BEGIN {printme=1} $0==placeholder {printme=0} printme {print}' "$HOSTS_FILE" > "$TEMP_HOSTS_FILE"
    awk -v placeholder="$PLACEHOLDER" 'BEGIN {printme=0} $0==placeholder {printme=1} printme && $0 != placeholder {print}' "$HOSTS_FILE" | sort > "$TEMP_HOSTS_FILE_SORTED"
    {
        cat "$TEMP_HOSTS_FILE"
        echo "$PLACEHOLDER"
        cat "$TEMP_HOSTS_FILE_SORTED"
    } > "$HOSTS_FILE"
    rm -f "$TEMP_HOSTS_FILE"
    rm -f "$TEMP_HOSTS_FILE_SORTED"
}

function fetch_and_update() {
    for url in "${URL_LIST[@]:-}"; do
        local -i LINE_COUNT=0
        while read -r line; do
            [[ -z "$line" || "$line" == \#* ]] && continue
            ((LINE_COUNT++)) || true
            if [[ "$line" == 0.0.0.0* ]]; then
                grep -qFx "$line" "$HOSTS_FILE" || { echo "$line" >> "$HOSTS_FILE"; }
            else
                grep -qFx "0.0.0.0 $line" "$HOSTS_FILE" || { echo "0.0.0.0 $line" >> "$HOSTS_FILE"; }
            fi
            
        done < <(curl -s "$url")
        printf "Fetched %d lines from %s\n" "$LINE_COUNT" "$url"
    done
    count_adresses_blocked
}

function count_adresses_blocked(){
    local -i COUNT=0
    COUNT=$(awk "/$PLACEHOLDER/{flag=1;next}/^$/{flag=0}flag" "$HOSTS_FILE" | wc -l)
    printf "Great! %d addresses have been added to %s\n" "$COUNT" "$HOSTS_FILE"
}

function schedule_cron() {
    ensure_script_installed
    [ -f "$CRON_FILE" ] || echo "0 $CRON_HOUR */2 * * root $SCRIPT_PATH --reload" > "$CRON_FILE" && chmod 644 "$CRON_FILE"
}

function reload_hosts_resolver() {
    local CURRENT_HOUR
    CURRENT_HOUR=$(date +%H)
    if [ "$CURRENT_HOUR" -ge 3 ] && [ "$CURRENT_HOUR" -lt 6 ]; then
        systemctl restart dnsmasq.service
    fi
}

function ensure_script_installed() {
    if ! $WORKFLOW_MODE; then
        if [ ! -f "$SCRIPT_PATH" ]; then
            printf "Script not found. Installing...\n"
            ln -s "$PWD/public-tracker-blocker.sh" /usr/local/bin/public-tracker-blocker
            printf "Script installed.\n"
        fi
    fi
}

function self_update() {
    cd /opt/public-tracker-blocker || { printf "Script not found.\n"; exit 1;}
    git pull
    printf "Script updated.\n"
    exit 0
}

function print_usage() {
    printf "Usage: %s [--reload] [--update] [--help]\n" "$0"
    printf "Options:\n"
    printf "  --reload\t\tReload network after updating hosts file\n"
    printf "  --update\t\tUpdate script to latest version\n"
    printf "  --help\t\tPrint this help message\n"
    exit 0
}

for arg in "$@"; do
    case $arg in
        --help)
            print_usage
        ;;
        --reload)
            RELOAD_NETWORK=true
            shift
        ;;
        --update)
            self_update
        ;;
        --workflow)
            declare WORKFLOW_MODE=true
            shift
        ;;
        *)
            shift
        ;;
    esac
done

main() {
    check_root
    printf "Updating host file...\n"
    workflow_mode
    ensure_placeholder
    fetch_base_list
    truncate_hosts
    fetch_and_update
    schedule_cron
    [ "$RELOAD_NETWORK" = true ] && [ "$WORKFLOW_MODE" = false ] && reload_hosts_resolver
    printf "Host file updated.\n"
}

main "$@"
